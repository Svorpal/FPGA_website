
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>ECE 5760 Final Project</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">FPGA-accelerated Boid Algorithm Simulation on VGA</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#demo">Demo</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#background">Background</a></li>
            <li><a href="#baseline">Baseline Design</a></li>
            <li><a href="#alt-high">High-Level Alternative Design</a></li>
            <li><a href="#alt-vga">Low-Level Alternative Design </a></li>
            <li><a href="#alt-sram">Alt Design : SRAM </a></li>  
            <li><a href="#alt-hps">Alt Design : HPS</a></li>
            <li><a href="#alt-fpga">Alt Design : FPGA</a></li>22
            <li><a href="#testing">Testing & Result</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
            <li><a href="#team">Team</a></li>
            <li><a href="#appendix">Appendix</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="starter-template">
        <h1>FPGA-accelerated Boid Algorithm Simulation on VGA   </h1>
        <p class="lead">ECE 5760 Advanced Microcontroller Final Project <br> By Michael Wu, Yen-Hsing Li, Matt Hales</p>
      </div>

      <hr id="demo">
      <br> <br> <br> <br> <br> <br>

      <div style="text-align:center;">
          <h2>Demo</h2>
           <div class="center-block">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/Z_ePWHn3OK8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
          </div>
      </div>

    <hr id='intro'>
      <br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Introduction</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Using a combination of the ARM A9 processor and DE1 SoC FPGA, our project successfully simulated dynamic boid (‘bird-oid object') flocking patterns, with a focus on optimizing cycle requirements and execution time. We first started with creating a “baseline” design strictly running on the ARM A9 processor. This baseline design was created using C code and was capable of computing the flocking patterns with a maximum number of 3,000 boids at 60 frames per second. Our “alternative” design was to create an update function on the FPGA that would calculate and update each boid’s position, in x and y coordinates, and they’re velocity, in the x and y directions as well. In the end, we were successfully able to simulate boid flocking patterns on the FPGA with a maximum number of 150 boids being displayed. Our goal with this project was to ideally improve the number of cycles required for the total boid update function and see an improvement in the overall execution time. We believed that if we could decrease the number of cycles with dedicated hardware running the update, we could eventually do the calculations for more than 3,000 boids, as found on the ARM processor.</p>
      </div>

    <hr id='background'>
      <br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Boid Algorithm</h2>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The rationale behind our project idea came from Professor Hunter Adam’s ECE 4760 boids lab, where students created a boid implementation in C using a Raspberry Pi 2040[1]. To create the flocking simulation, there are three main steps to follow: separation, alignment, and cohesion. In separation, the boids that are too close move away from each other. In alignment, the boids that are close with their neighbors will try to match the speed of the neighboring boids. Lastly, in cohesion, the boids will move toward the center of the neighbors to create a smaller group of boids。</p>

              <img class="img-rounded" src="pictures/BoidProtect_Visual_range.png" alt="Generic placeholder image", height="550">
              <h3> <b>Figure 1. Determining Separation, Alignment, and Cohesion[1] </b> </h3> <br> 

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> Figure 1 above details when separation, alignment, and cohesion need to occur and provides a visual representation of the logic required for each process. </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> When boids are too close together, we perform two steps to make the boids spread out a little bit. The first step is to calculate the distance of the current boid to the closest boid. </p>

              <div class="row">
              <pre><code style="font-size:18px;">
                close_dx += boid.x - otherboid.x
                close_dy += boid.y - otherboid.y
              </code></pre>
             </div>

             <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> Once this has been calculated, we created a factor for avoidance: avoidfactor. This avoid factor, while still relatively small, will be multiplied by the <em>close_dx</em> and <em>close_dy</em> values previously calculated: </p>

             <div class="row">
              <pre><code style="font-size:18px;">
                boid.vx += close_dx*avoidfactor
                boid.vy += close_dy*avoidfactor
              </code></pre>
             </div>

             <img class="img-rounded" src="pictures/BoidAvoidFactor.png" alt="Generic placeholder image", height="550">
              <h3> <b>Figure 2. Boid Separation[1]</b> </h3> <br> <hr>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The next step is the calculation required for alignment. As previously mentioned, alignment is when each boid attempts to match the velocity of the boids inside its visible range, shown in Figure 1. To perform the alignment, we perform the following steps: <br> <br>

              1. At the start of the update for a particular boid, three variables (<em>xvel_avg</em>, <em>yvel_avg</em>, and <em>neighboring_boids</em>) are zeroed.<br>
              2. We loop through every other boid. If the distance to a particular boid is less than the visible range, then <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> xvel_avg += otherboid.vx </em> <br> 
              <em> yvel_avg += otherboid.vy </em>
              <em> neighboring_boids += 1 </em>
              </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px">3. Once we've looped through all other boids, we do the following <b> if <em>neighboring_boids</em> >  0: </b><br> <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> xvel_avg = xvel_avg/neighboring_boids</em> <br> 
              <em> yvel_avg = yvel_avg/neighboring_boids </em>
              </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px">4. We then update the velocity according to: <br> <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> boid.vx += (xvel_avg - boid.vx)*matchingfactor</em> <br> 
              <em> boid.vy += (yvel_avg - boid.vy)*matchingfactor </em> <br>
              (where <b>matchingfactor</b> is a tunable parameter)
              </p>      

             <img class="img-rounded" src="pictures/BoidAlignFactor.png" alt="Generic placeholder image", height="550">
              <h3> <b>Figure 3. Boid Alignment[1]</b> </h3> <br> <hr>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The last boid on boid update is based on cohesion, as each boid steers gently toward the center of mass of other boids within its visible range. It does so in the following way: <br> <br> </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px">1. At the start of the update for a particular boid, three variables (<em>xpos_avg</em>, <em>ypos_avg</em>, and <em>neighboring_boids</em>) are zeroed <br> </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px">2. We loop through every other boid. If the distance to a particular boid is less than the visible range, then <br> <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> xpos_avg += otherboid.x</em> <br> 
              <em> ypos_avg += otherboid.y </em> <br>
              <em> neighboring_boids += 1 </em> <br>
              </p> 


              <p style="text-align: left;padding: 0px 30px;font-size:18px">3. Once we've looped through all other boids, we do the following <b> if <em>neighboring_boids</em> >  0: </b><br> <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> xpos_avg = xpos_avg/neighboring_boids</em> <br> 
              <em> ypos_avg = ypos_avg/neighboring_boids </em>
              </p> 

              <p style="text-align: left;padding: 0px 30px;font-size:18px">4. We then update the velocity according to: <br> <br> </p>

              <p style="text-align: center;padding: 0px 30px;font-size:18px;"> <em> boid.vx += (xpos_avg - boid.x)*centeringfactor </em> <br> 
              <em> boid.vy += (ypos_avg - boid.y)*centeringfactor </em> <br>
              (where <b>centeringfactor</b> is a tunable parameter)
              </p>      

              <img class="img-rounded" src="pictures/BoidCenteringAndMatching.png" alt="Generic placeholder image", height="550">
              <h3> <b>Figure 4. Boid Cohesion[1]</b> </h3> <br> <hr>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The last step for the boid update is determining when the boids need to turn so all boids stay within the confines of the VGA screen we are using. This is simply done by the following conditional statements: <br> </p>
              
              <img class="img-rounded" src="pictures/fuck.png" alt="Generic placeholder image", height="350"> <br>


              <img class="img-rounded" src="pictures/BoidBoundaries.png" alt="Generic placeholder image", height="350">
              <h3> <b>Figure 5. Screen Boundary Conditions[1]</b> </h3> <br>      

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> Figure 5 is from an outdated lab manual when using a different microcontroller and display, though the logic behind the boundary conditions stays the same. </p>

      </div>

    <hr id='baseline'>
      <br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Baseline Design</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The first step of the project was to create a baseline version of the boids algorithm in C that implemented the algorithm described above. We created multiple functions to help us achieve our goal: a list of boids, boid_initialize, spawnBoid, boundary_check, and boid_update. The list of boids was initialized by a struct that contained five variables: pos_x, pos_y, vx, vy, and color. As the names suggest, the pos_x and pos_y variables store the x and y coordinates of each boid, while the vx and vy variables store the velocity in the x and y direction. The color variable was used to specify the color when drawing each boid. For our case, we chose to keep each boid white for easier visuals as the background color of our display was black.</p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> When spawning boids, we created the spawnBoid function that would take the x and y coordinates of the boid as well as the vx and vy velocities values. Inside the function, a random starting position was assigned as well as a random speed value. Ideally, we wanted the boids to start in a new location every time the simulation ran to provide a unique simulation each run. </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> Additionally, the boundary_check function was created to enact the turnfactor variable, as described previously. This variable determines when the boids need to change direction, specifically when they are outside the boundary. Our design creates a boundary smaller than the size of the VGA display. This is done to better visualize how the boids move. To allow for this execution, we created 4 helper functions: hitTop, hitBottom, hitRight, hitLeft. Each of these helper functions hold the values for the x positions (hitLeft and hitRight) and y position (hitTop and hitBottom) of the boundaries, checking if a boid is beyond it. If either the boid’s x or y positions were outside of these bounds, then either the x and / or y velocities will be updated by the value of the turn factor.  </p>

               <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Lastly, we created the boid_update function that executed the boid algorithm. For the boid algorithm to work correctly, we need to loop through every boid we are simulating. Within each iteration we did the following: <br>
              </p>

              <ol>
                <li> <p style="text-align: left;padding: 0px 30px;font-size:18px;"> Check for boids within the visual range. </p></li>
                <li> <p style="text-align: left;padding: 0px 30px;font-size:18px;">If there is a boid within the visual range, calculate the square distance between the current boid and the neighbor boid.  </p></li>
                <li> <p style="text-align: left;padding: 0px 30px;font-size:18px;">Check if the distance from the current boid to the neighbor boid is less than the protected range. If true, update the coordinates delta for both x and y.  </p> </li>
                <li> <p style="text-align: left;padding: 0px 30px;font-size:18px;">Check if the distance from the current boid to the neighbor boid is within the visual range. If true, calculate the x position, y position, x velocity, and y velocity averagesIf true, update the coordinates delta for both x and y. Increment the number of neighboring boids by one.  </p></li>
              </ol>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> After the loop has finished, we then need to modify the current boid’s position and velocities. The first thing we do is check how many neighboring boids have been identified and divide the x and y position averages and the x and y velocity averages by the number of neighboring boids. We also compute the centering factor and matching factors by adding the current x velocity with a multiplication of the (x position - current boids x position) with the centering factor and adding another multiplication of (x velocity average - current boids x velocity) with the matching factor. We perform the same step again but for the y velocity. Once the x and y velocities have been updated, we then perform another multiplication on these velocities, this time with the delta values for x and y we calculated earlier and the avoidance factor. We then add the result of the multiplication to the x and y velocity values. </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> At this point in the algorithm, we need to perform the boundary check to implement the turn factor if the boid is now outside the boundary. This is done by simply calling the boundary_check function on the current boid. </p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> The last part of the algorithm is dedicated to enforcing a maximum and minimum speed and updating the x and y positions based on the velocity values we’ve calculated. We first check if the current speed of the boid is greater than or less than the minimum and maximum by performing the alpha max plus beta min algorithm. This algorithm is a quick algorithm for calculating the square root. If the speed is less than the minimum speed or greater than the maximum speed allowed, we perform the following action:</p>

              <div align="left";>
                <pre><code style="text-align: left;font-size:18px;">
                  if (speed < minspeed && speed != 0) {
                       *vx = multfix15(divfix(*vx,speed),minspeed);
                       *vy = multfix15(divfix(*vy,speed),minspeed);
                  }


                  if (speed > maxspeed) {
                       *vx = multfix15(divfix(*vx,speed),maxspeed);
                       *vy = multfix15(divfix(*vy,speed),maxspeed);
                  }

                </code></pre>
             </div>   

            <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">  Lastly, we increment the x and y positions by the x and y velocities by simply adding or subtracting the two values. </p>

            <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">  With the algorithm completed, we were able to simulate boids interacting with each other and the boundaries. Additionally, on the ARM processor, we were successfully able to simulate up to 3,000 boids at a speed of 60 frames per second! </p>


      </div>

    <hr id='alt-high'>
      <br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Alternative Design: High Level</h2>

              <img class="img-rounded" src="pictures/SRAM.png" alt="Generic placeholder image">
              <h3> <b>Figure 6. High-Level System Diagram of Alternative Design</b> </h3> <br>     

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">In our alternative design, we aim to speed up calculation time for the boid algorithm. To do so, we migrate the implementation of the boid algorithm from the HPS side to the C side. Furthermore, we decided to keep drawing functionalities on the HPS side because we would like to let the FPGA work on the boid algorithm only and have no hardware overhead from drawing. In order to transmit data between the FPGA and the HPS, we use on-chip SRAM consisting of M10 blocks as a memory buffer between hardware and software.</p>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> As shown in the system design diagram, The ARM on the HPS side stores the current data of all the boids (x-coordinate, y-coordinate, velocity in the x-direction, velocity in the y-direction) in dedicated addresses of the SRAM. On the other hand, the FPGA reads from those addresses, and stores the acquired data in local arrays updating boids’ locations and speeds according to the boid algorithm, and then stores the updated information back on the same addresses in the SRAM. Later, the ARM reads from corresponding addresses in the SRAM, looks for updated boid information, and draws the boids at new locations with new speeds on the VGA screen.  </p>
      </div>

    <hr id='alt-vga'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Alternative Design: Low Level</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Starting from this part, we will go through the low-level design of  VGA, SRAM, HPS, and FPGA sides respectively. </p>
              <h3> Alternative Design Low Level: VGA </h3>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> The HPS uses the VGA subsystem module to draw on the VGA screen. 
              The code we used for drawing on the VGA was from <a href="https://people.ece.cornell.edu/land/courses/ece5760/"> ECE 5760 class website</a>. under <a href="https://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HPS_peripherials/Examples_version_18.html"> “DE1-SoC: Examples verified for Quartus version18.1” </a> , and named “<b>GPU with FAST display from SRAM</b>”. [2]</p> 
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> Since we are only using the HPS to draw the VGA, we are using the simple graphics processor for the HPS side to draw on the VGA screen from this code. We retain the original Qsys VGA subsystem and dual-ported SRAM for the VGA frame buffer. </p>
      </div>

    <hr id='alt-sram'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h3>Alternative Design Low Level: SRAM</h3>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">The on-chip SRAM we use is composed of M10k memory blocks because it supports bi-directional dual-port access. We choose the data size to be 32 bits as the fixed number we use is 32 bits with 15 bits after the decimal point. For total memory size, 4096 bytes was used for our 100-boid implementation as each boid needs 4 memory addresses to store its x position, y position, x velocity, and y velocity.  Later when we try to implement 1000 boids, we change the total memory size to 16384 bytes. </p>

              <img class="img-rounded" src="pictures/SRAM (1).PNG" alt="Generic placeholder image">
              <h3> <b>Figure 7. Qsys SRAM Module Setting</b> </h3> <br> <hr>

              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;"> In Qsys, in the end, we created the on-chip memory module. Its clock is connected to the system clock from the system PLL, its reset is connected to the System PLL reset and ARM HPS reset, and its s1 is connected to the Altera AXI master as a slave. Since the SDRAM used for VGA display is also connecting to the Altera AXI master as a slave and has its address from 0x0000_0000 to 0x03ff_ffff, we change the base and end of the on-chip SRAM to be from 0x0400_0000 to 0x0400_3FFF. </p>

              <img class="img-rounded" src="pictures/Qsys1.png" alt="Generic placeholder image">
              <h3> <b>Figure 8. Qsys Connection, Part I</b> </h3>

              <img class="img-rounded" src="pictures/Qsys2.png" alt="Generic placeholder image">
              <h3> <b>Figure 9. Qsys Connection, Part II</b> </h3> <br>
              
      </div>

    <hr id='alt-hps'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h3>Alternative Design Low Level: HPS</h3>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>

    <hr id='alt-fpga'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h3>Alternative Design Low Level: FPGA</h3>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>
    <hr id='testing'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Testing</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>

    <hr id='conclusion'>
<br> <br> <br> <br> <br> <br>
      <div style="text-align:center;">
              <h2>Conclusion</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:18px;text-indent: 55px;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem nulla, consectetur at leo vel, pretium bibendum nisl. Cras blandit quam a enim ultrices, eu convallis enim posuere. Donec eleifend enim sed purus consectetur, vitae cursus lectus varius. Vivamus consectetur felis nec est venenatis posuere. Phasellus vitae aliquet erat. In laoreet lacinia mollis. Quisque iaculis nisl fermentum pharetra lobortis. Donec rhoncus dui sem, ac molestie leo tristique vel. Phasellus in nibh feugiat, fringilla lectus in, elementum magna. Etiam quis dui condimentum, tempus ex in, dapibus est. Cras ut congue augue. Donec ac enim ex. Ut id tristique risus, vel porttitor quam. Sed ultricies enim eu nibh porttitor, vel sodales enim feugiat. Fusce volutpat venenatis magna ac ultrices. Curabitur eget urna ut nulla mattis convallis non eu diam.</p>
      </div>

    <hr id='team'>
<br> <br> <br> <br> <br> <br>
    <div class="row" style="text-align:center;">
          <h2>Work Distribution</h2>
          <div style="text-align:center;">
              <img class="img-rounded" src="pics/group.jpg" alt="Generic placeholder image" style="width:80%;">
              <h4>Project group picture</h4>
          </div>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/a.png" alt="Generic placeholder image" width="240" height="240">
              <h3>Rick</h3>
              <p class="lead">netid@cornell.edu</p>
              <p>Designed the overall software architecture (Just being himself).
          </div>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/b.png" alt="Generic placeholder image" width="240" height="240">
              <h3>Morty</h3>
              <p class="lead">netid@cornell.edu</p>
              <p>Tested the overall system.
          </div>
      </div>

    <hr id='appendix'>
<br> <br> <br> <br> <br> <br> 
      <div class="row">
              <h2>Code Appendix</h2>
              <pre><code>
// Hello World.c
int main(){
  printf("Hello World.\n");
}
              </code></pre>
      </div>

    </div><!-- /.container -->




    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script> -->
  </body>
</html>
